classdef UTCrazyflie6DOF    
    methods (Access = public)
        function self = UTCrazyflie6DOF()
            self.start()
        end
        
        function start(~)
            close, clc;
            
            % Simulation-time parameters
            tFinal = 25;
            period = 0.1;
            initStates = zeros(1,12);
            
            % Desired positions (x, y, z, yaw)
            positions = ITrajectory(tFinal, period, 'meters');
            positions.add([0 0 -0.5 0.5 0 0]) % x
            positions.add([0 0 -1 0 0]) % y
            positions.add([0 0.5 0.5 0.5 0.5 0]) % z
            positions.add([0 -.1 -.1 -.1 -.1 -.1 0]) % yaw
            
            kT = positions.getInstants();
            samples = positions.getSamples();
            
            % Instance of nonlinear model
            plant = PlantFactory.create(PlantList.crazyflie6DOF);
            plant.setPeriod(period)
            plant.setInitialStates(samples, initStates)
            
            % Controller parameters
            controllerType = ControllerTypes.WavenetPID;
            controllerGains = struct('altitude', [1 0.1 1], ...
                                     'heading', [1 0.1 1], ...
                                     'xposition', [1 0 1], ...
                                     'yposition', [1 0 1], ...
                                     'roll', [1 0.1 0], ...
                                     'pitch', [1 0.1 0], ...
                                     'rollrate', [1 0.1 1], ...
                                     'pitchrate', [1 0.1 1], ...
                                     'yawrate', [1 0.1 1], ...
                                     'temp', [1 0 0]);
            controllerRates = struct('altitude', 1e-2.*zeros(1,3), ...
                                     'heading', 1e-2.*zeros(1,3), ...
                                     'xposition', 1e-2.*zeros(1,3), ...
                                     'yposition', 1e-2.*zeros(1,3), ...
                                     'roll', 1e-2.*zeros(1,3), ...
                                     'pitch', 1e-2.*zeros(1,3), ...
                                     'rollrate', 1e-2.*zeros(1,3), ...
                                     'pitchrate', 1e-2.*zeros(1,3), ...
                                     'yawrate', 1e-2.*zeros(1,3), ...
                                     'temp', 1e-2.*zeros(1,3));
            
            % PID controller to regulate the altitude (z) 
            altCtrl = ControllerFactory.create(controllerType);
            altCtrl.setGains(controllerGains.altitude)
            altCtrl.setUpdateRates(controllerRates.altitude)
            altCtrl.initPerformance(samples)
            
            % PID controller to regulate the heading (yaw)
            yawCtrl = ControllerFactory.create(controllerType);
            yawCtrl.setGains(controllerGains.heading)
            yawCtrl.setUpdateRates(controllerRates.heading)
            yawCtrl.initPerformance(samples) 
            
            % PD controllers to regulate the positions (x and y)
            xpsCtrl = ControllerFactory.create(controllerType);
            xpsCtrl.setGains(controllerGains.altitude)
            xpsCtrl.setUpdateRates(controllerRates.altitude)
            xpsCtrl.initPerformance(samples)
            
            ypsCtrl = ControllerFactory.create(controllerType);
            ypsCtrl.setGains(controllerGains.altitude)
            ypsCtrl.setUpdateRates(controllerRates.altitude)
            ypsCtrl.initPerformance(samples)
            
            % PI controllers to regulate attitude (roll and pitch)
            rollCtrl = ControllerFactory.create(controllerType);
            rollCtrl.setGains(controllerGains.roll)
            rollCtrl.setUpdateRates(controllerRates.roll)
            rollCtrl.initPerformance(samples)
            
            pitchCtrl = ControllerFactory.create(controllerType);
            pitchCtrl.setGains(controllerGains.pitch)
            pitchCtrl.setUpdateRates(controllerRates.pitch)
            pitchCtrl.initPerformance(samples)
            
            % PID controllers to regulate the angular rates (roll, pitch and yaw)
            rollrateCtrl = ControllerFactory.create(controllerType);
            rollrateCtrl.setGains(controllerGains.rollrate)
            rollrateCtrl.setUpdateRates(controllerRates.rollrate)
            rollrateCtrl.initPerformance(samples)
            
            pitchrateCtrl = ControllerFactory.create(controllerType);
            pitchrateCtrl.setGains(controllerGains.pitchrate)
            pitchrateCtrl.setUpdateRates(controllerRates.pitchrate)
            pitchrateCtrl.initPerformance(samples)
            
            yawrateCtrl = ControllerFactory.create(controllerType);
            yawrateCtrl.setGains(controllerGains.yawrate)
            yawrateCtrl.setUpdateRates(controllerRates.yawrate)
            yawrateCtrl.initPerformance(samples)
            
            for iter = 1:samples
                sDesired = positions.getReferences(iter);
                
                v1 = altCtrl.getSignal();
                v2 = rollrateCtrl.getSignal();
                v3 = pitchrateCtrl.getSignal();
                v4 = yawrateCtrl.getSignal();
                
                u = [v1 v2 v3 v4];
                
                realStates = plant.measured(u, iter);
                
                xError = sDesired(1) - realStates(1);
                yError = sDesired(2) - realStates(3);
                
                xpsCtrl.autotune(xError, 0, 0)
                ypsCtrl.autotune(yError, 0, 0)
                
                xpsCtrl.evaluate()
                ypsCtrl.evaluate()
                
                rollDesired = xpsCtrl.getSignal();
                pitchDesired = ypsCtrl.getSignal();
                
                rollError = rollDesired - 
            end
            
            desired = positions.getAllReferences();
            measurement = plant.getPerformance([1 3 5 11]);
            
            figure(1)
                subplot(2, 3, 1)
                hold on
                plot(kT, desired(:,1))
                plot(kT, measurement(:,1))
                xlabel('Time [sec]')
                ylabel('x [m]')
                
                subplot(2, 3, 2)
                plot(kT, desired(:,2))
                hold on
                plot(kT, measurement(:,2))
                xlabel('Time [sec]')
                ylabel('y [m]')
                
                subplot(2, 3, 4)
                plot(kT, desired(:,3))
                hold on
                plot(kT, measurement(:,3))
                xlabel('Time [sec]')
                ylabel('z [m]')
                
                subplot(2, 3, 5)
                plot(kT, desired(:,4))
                hold on
                plot(kT, measurement(:,4))
                xlabel('Time [sec]')
                ylabel('yaw [rad]')
                
                subplot(2, 3, [3 6])
                plot3(desired(:,1), desired(:,2), desired(:,3), ...
                    measurement(:,1), measurement(:,2), measurement(:,3))
                xlabel('x [m]')
                ylabel('y [m]')
                ylabel('z [m]')
        end
        
%         function run(self)
%             close, clc;
%             
%             tFinal = 10;
%             period = 0.1;
%             initStates = zeros(1,12);
%             
%             positions = ITrajectory(tFinal, period, 'meters');
%             positions.add([0 -0.5 0.5 0]) 
%             positions.add([0 2 2 2 0])
%             positions.add([0 1 10 6 1 0])
%             
%             samples = positions.getSamples();
%             
%             self.model = PlantFactory.create(PlantList.crazyflie6DOF);
%             self.model.setPeriod(period)
%             self.model.setInitialStates(samples + 1, initStates)
%             
%             self.perfCtrls = zeros(samples, 4);
%             
%             perfVels = zeros(samples, 4);
%             perfRPM = zeros(samples, 4);
%             
%             % Controller parameters
%             controllerType = ControllerTypes.WavenetPID;
%             controllerGains = struct('rotor1', [1 0 0], ...
%                                      'rotor2', [1 0 0], ...
%                                      'rotor3', [1 0 0], ...
%                                      'rotor4', [1 0 0]);
%             controllerRates = struct('rotor1', 1e-2.*zeros(1,3), ...
%                                      'rotor2', 1e-2.*zeros(1,3), ...
%                                      'rotor3', 1e-2.*zeros(1,3), ...
%                                      'rotor4', 1e-2.*zeros(1,3));
%             
%             % Building the 1st rotor controller            
%             rotor1Ctrl = ControllerFactory.create(controllerType);
%             rotor1Ctrl.setGains(controllerGains.rotor1)
%             rotor1Ctrl.setUpdateRates(controllerRates.rotor1)
%             rotor1Ctrl.initPerformance(samples)
%             
%             % Building the 2nd rotor controller
%             rotor2Ctrl = ControllerFactory.create(controllerType);
%             rotor2Ctrl.setGains(controllerGains.rotor2)
%             rotor2Ctrl.setUpdateRates(controllerRates.rotor2)
%             rotor2Ctrl.initPerformance(samples)
%             
%             % Building the 3rd rotor controller
%             rotor3Ctrl = ControllerFactory.create(controllerType);
%             rotor3Ctrl.setGains(controllerGains.rotor3)
%             rotor3Ctrl.setUpdateRates(controllerRates.rotor3)
%             rotor3Ctrl.initPerformance(samples)
%             
%             % Building the 4th rotor controller
%             rotor4Ctrl = ControllerFactory.create(controllerType);
%             rotor4Ctrl.setGains(controllerGains.rotor4)
%             rotor4Ctrl.setUpdateRates(controllerRates.rotor4)
%             rotor4Ctrl.initPerformance(samples)
%             
%             controllers = [rotor1Ctrl, rotor2Ctrl, rotor3Ctrl, rotor3Ctrl];
%             
%             
%             arrange = [ 1 -1 -1  1;
%                         1  1 -1 -1;
%                         1  1  1  1;
%                         1 -1  1 -1];
%                         
%             for iter = 1:samples
%                 yRef = positions.getReferences(iter);
%                 
%                 uRef = [controllers(1).getSignal() ...
%                         controllers(2).getSignal() ...
%                         controllers(3).getSignal() ...
%                         controllers(4).getSignal()];
%                 
%                 u = [uRef(1) uRef(2) uRef(3) uRef(4)];
%                 
%                 P = arrange * u';
%                 RPM = 0.2685 * P + 4070.3;
%                 w = RPM * pi / 30;
%                 
%                 wr = -w(1) + w(2) - w(3) + w(4);
%                 
%                 realStates = self.model.measured(u, wr, iter);
%                 self.perfCtrls(iter,:) = u;
%                 perfVels(iter,:) = w;
%                 perfRPM(iter,:) = P;
%                 
%                 eTracking = yRef - realStates([1 3 5]);
%                 
%                 controllers(1).autotune(eTracking(1), 0, 0)
%                 controllers(2).autotune(eTracking(1), 0, 0)
%                 controllers(3).autotune(eTracking(1), 0, 0)
%                 controllers(4).autotune(eTracking(2), 0, 0)
%                 
%                 controllers(1).evaluate()
%                 controllers(2).evaluate()
%                 controllers(3).evaluate()
%                 controllers(4).evaluate()
%             end
%             
%             figure(1)
%             for idx = 1:length(self.perfCtrls(1,:))
%                 subplot(3, length(self.perfCtrls(1,:)), idx)
%                 plot(self.perfCtrls(:, idx),'r','LineWidth',1)
%                 ylabel(sprintf('v_%i', idx))
%             end
%             
%             for idx = 1:length(self.perfCtrls(1,:))
%                 subplot(3, length(perfVels(1,:)), idx + 4)
%                 plot(perfVels(:, idx),'r','LineWidth',1)
%                 ylabel(sprintf('w_%i', idx))
%             end
%             
%             for idx = 1:length(self.perfCtrls(1,:))
%                 subplot(3, length(perfRPM(1,:)), idx + 8)
%                 plot(perfRPM(:, idx),'r','LineWidth',1)
%                 ylabel(sprintf('P_%i', idx))
%             end
%             
%             figure(2)
%             performance = self.model.getPerformance([1 3 5 7 9 11]);
%             tags = {'x'; 'y'; 'z';  '\\phi'; '\\theta'; '\\psi'};
%             
%             desired = positions.getAllReferences();
%             
%             plot3(performance(:,1), performance(:,2), performance(:,3))
%             hold on
%             plot3(desired(:,1), desired(:,2), desired(:,3))
%             xlabel('x(t)')
%             ylabel('y(t)')
%             zlabel('z(t)')
%             
% %             figure(3)
% %             
% %             for idx = 4:length(performance(1,:))
% %                 subplot(1, 3, idx-3)
% %                 plot(time, performance(:,idx),'r','LineWidth',1)
% %                 ylabel(sprintf('%s', string(tags(idx))))
% %             end
%         end
    end
end