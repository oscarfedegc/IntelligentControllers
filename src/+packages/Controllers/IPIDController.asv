% This class implements the PID Controller and its methods to calculate the
% control signal and autotune its gains.
classdef IPIDController < Controller
    methods (Access = public)
        % Class constructor.
        %
        %   @returns {object} self Is the instantiated object.
        %
        function self = IPIDController()
            self.signal = 0;
            self.gains = rand(1,3);
            self.updateRates = zeros(1,3);
            self.eTrackingMemory = zeros(1,3);
        end
        
        % Defines the gains autotune algorithm.
        %
        %   @param {object} self Stands for instantiated object from this class.
        %   @param {float} trackingErr Difference between the desired position
        %                              and the real position.
        %   @param {float} identificationErr Difference between the real position and 
        %                                    the wavenet output.
        %   @param {float} gamma Represents a wavenet parameter.
        %
        function autotune(self, trackingErr, identificationErr, gamma)
            self.updateMemory(trackingErr)
            
            kp = self.gains(1);
            ki = self.gains(2);
            kd = self.gains(3);
            mp = self.updateRates(1);
            mi = self.updateRates(2);
            md = self.updateRates(3);
            ep = self.eTrackingMemory;
            
            kp = kp + mp*identificationErr*gamma*(ep(1) - ep(2));
            ki = ki + mi*identificationErr*gamma*ep(1);
            kd = kd + md*identificationErr*gamma*(ep(1) - 2*ep(2) + ep(3));
            
            self.gains = [kp ki kd];
        end
        
        % This function is responsable for store the tracking error into a
        % array memory.
        %
        %   @param {float} trackingError Difference between the desired
        %                                position and the real position.
        %
        function updateMemory(self, trackingError)
            self.eTrackingMemory = [trackingError, self.eTrackingMemory(1:2)];
        end
        
        % This function is in charge of calculate the control signal.
        %
        %   @param {object} self Stands for instantiated object from this class.
        function evaluate(self)            
            u = self.signal;
            kp = self.gains(1);
            ki = self.gains(2);
            kd = self.gains(3);
            ep = self.eTrackingMemory;
            
            new = u + kp*(ep(1) + ep(2)) + ki*ep(1) + kd*(ep(1) - 2*ep(2) + ep(3));
            
            self.signal = new;
        end
        
        % Shows the behavior of the gains and the control signal by means of a graph.
        %
        %   @param {object} self Stands for instantiated object from this class.
        %   @param {string} title Indicat
        function charts(self, title)
            figure('Name',title,'NumberTitle','off','units','normalized','outerposition',[0 0 1 1]);
            
            tag = {'Proportional'; 'Integral'; 'Derivative'};
            subs = {'p'; 'i'; 'd'};
            
            items = length(self.performance(1,:));
            for row = 1:items - 1
                subplot(items, 1, row)
                plot(self.performance(:,row),'r','LineWidth',1)
                ylabel(sprintf('%s, K_{%s}', string(tag(row)), string(subs(row))))
            end
            
            subplot(items, 1, items)
                plot(self.performance(:,items),'r','LineWidth',1)
                ylabel('Control signal, u [V]')
                xlabel('Samples, k')
        end
    end
end